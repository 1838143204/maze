<font size=5>实验内容简介</font>

> 基本要求:

从文件中读出迷宫数据,寻找并打印出路径通路;储存迷宫数据到文件.

文件中迷宫数据格式为:

长 宽 入口 出口 迷宫的地图数据

迷宫地图数据由01二进制组成,1表示墙壁,0表示通路

> 中级要求:

寻找多入口多出口地图的所有通路

>高级要求:

自动生成迷宫地图

---

<font size=5>程序设计思路</font>

从入口进行探索式遍历:分别向上下左右四个方向进行搜索,若不是墙则继续走,直到碰到墙或者遇到出口

---

<font size=5> 算法分析与设计</font>

![maze.bmp](.\maze.bmp "maze")

<font size=4>概念:</font>

> 可行方向:从当前位置出发,如果向相邻的位置行走,不会撞墙,且保证不会越界,则称该方向为当前节点的可行方向

> 可行节点:入口或者中间节点(经过该节点有到达入口和出口的通路),可行节点有两个不同的可行方向,且沿可行方向到达的下一个节点是可行节点

> 可行路径:从入口到出口的通路,连接所有可行节点

<font size=4>算法:</font>

1. <font size=3><font >找寻出路:</font>

    利用递归的思想,从入口出发,如果该节点可行方向上的下一个节点是可行节点,则该节点是可行节点.

    由此可以定义递归函数,使其返回值为该节点的可行状态(是否为可行节点),并递归调用该函数,使该节点记录其他方向(除来时的方向)下一节点的可行状态,并使该节点的可行状态改变为其余方向可行状态的并(即:当前节点可行状态=左边节点可行状态∪右边节点可行状态∪上方节点可行状态∪下方节点可行状态)

2. <font size=3>随机生成迷宫:</font>

    生成迷宫的基本思路为:从迷宫中心初开始,随机向四个方向走,直到马上与另一条通路相连通或者越界.

    该算法要求迷宫的边长为奇数,则可以设置起点在地图的正中间,且上下左右距离边界长度为偶数,这样我们以2为步长行走,所过之处设为道路,由于向四个方向走,可以证明道路一定延伸至边界,且四个顶点处一定为道路.在此基础上在四边加上墙便可以形成封闭的迷宫.在此基础上,利用四个内角为通路,可以设置固定的入口与出口,而对于多入口的迷宫,可以利用边界一定有通路的特性,随机设置入口与出口.

3.<font size=3>复杂度分析:</font>

    首先从该算法的性质入手,由于生成迷宫以2为步长,因此对于每四个节点,必然至少有一个节点是通路(因为如果全是墙,则生成迷宫时必然可以从周围延伸进这四个节点),且至少有一个节点是墙(因为如果全是通路,生成迷宫时必然需要从相同的方向并列延伸至此,而步长为2,因此相邻的并行路线只能是相邻位置,即九宫格的两侧位置,而非并列的位置),所以通路的节点数为介于 n^2/4 ~ 3*n^2/4 之间,假设对每一个结点的操作时间复杂度为O(1),由于步长为2,因此只对一半的通路节点被操作,则生成迷宫的复杂度为O(3*n^2/8)对,于寻找出路的算法,对于每个节点都有操作,且只操作一次,因此寻路算法时间复杂度为O(3*n^2/4)

---

<font size=5>数据结构设计</font>

```cpp
class node{
    public:
    bool state;//记录节点的状态(墙或通路)
    int flag;//记录该节点是否是可行节点(-1表示未知,0表示否,1表示是)
    bool up;//向上是否可以出去
    bool down;//向下是否可以出去
    bool left;//向左是否可以出去
    bool right;//向右是否可以出去
    private:
    node();//构造函数
    bool GetState(){return state};//查看该位置是否可行走
    void ChangeState(bool new_taste){state=new_state};//改变该位置的状态,用于生成迷宫
    void ChangeFlag(int new_flag){flag=new_flag};//改变该位置的可行状态,用于找寻通路
}
```

